# FiniteStateMachine

## Для сборки проекта достаточно в корне:
mkdir build
cd build
cmake ..
make
Для запуска тестов можно перейти в src/bin и исполнить бинарник
Бинарник для запуска основной программы лежать будет в build  

Если вы хотите запустить через Clion, можно открыть как проект и запустить либо run для программы либо BasicFsmTests - это запустит все тесты  

# Краткое описание необходимых методов:
### NFSM:
- NFSM(filename) - делает из данного файла NFSM
- FilchEps() - стягивает eps-переходы
- bool RecognizeWord(word) - возвращает результат принадлежания word языку этого автомата
### DFSM:
- DFSM(NFSM) - конструктор из NFSM
- DFSM(filename) - конструктор из файла, при этом будьте внимательны входной автомат должен быть ПДКА
- bool RecognizeWord(word) - ...
### MDFSM
- MDFSM(DFSM) - делает из DFSM минимизируя его
- RecoginzeWord(word) - ...
- Complement() - преобразуется в дополнение
### RegularFSM
Этот класс отвечает за построение регулярки - на самом деле это не автомат)))
- Regular_automat(DFSM) - конструктор из DFSM
- MakeRegular() - преобразует себя в подобающий для дальнейшего вид - рекомендуется исполнятт всякий раз после создания
- PrintRegex() - выводит регулярку в командную строку
- PrintForLatex() - выводит ту же регулярку чтоб закинуть ее в Latex

При этом в дирректории tests/SM_examples вы можете посмотреть некоторые автоматыи как их вводить, в частности:
## Для NFSM:
|Q| |delta|(это кол-во переходов)  
Маски для состояний(1 - завершающее, 0 - нет)  
переходы (q1, v) -> q2 в формате q1_v_q2  
## Для MDFSM
- |Q|
Маски для состояний(1 - завершающее, 0 - нет)
i j - где i, j - это переходы из данной вешины(по номеру запроса) в буквы a и b  


При этом можно обобщить на больший алфавит но те же входные данные мои не пойдут но можно прееделать очевидным образом и изменить глобальную константу

### Регулярка для моих тестовых автоматов:
1. a+
2. (a+b)
3. (1 + (a+b)*b)b(a+b)*
4. (ab+ba)*(1 + a + ba)
5. (aa)*b + ((a+b)^2)*

